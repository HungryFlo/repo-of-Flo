[TOC]



# 任务1

## 题目：为指定的 List ADT 实现各种数据结构 

![70203761917](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1702037619179.png)

## 顺序数组实现

### 数据设计

使用泛型类`<T>` 的数组实现线性表List

### 算法设计

#### `moveToNth`

若数组元素个数小于等于n，不符合操作前提，输出错误信息；

若数组元素个数大于等于n+1，将curr所指的元素取出来，将curr+1到n的元素向前移动一位，再将该元素放入第n个位置中。

#### `find`

从curr所指的位置开始，让curr不断后移，直到搜索到目标元素或指向数组末尾。

### 主干代码说明

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class AList<T> implements List<T>{
    private static final int defaultSize = 512;
    private int msize;
    private int numInList;
    private int curr;
    private T[] listArray;
	//构造函数
    AList(){
        setup(defaultSize);
    }
    //单独的setup函数，方便后面调用
    private void setup(int size){
        msize = size;
        numInList = 0;
        curr = -1;
        listArray = (T[]) new Object[size];
    }
    @Override
    public void insert(T newElement) throws ListException {
        if (isFull()) throw new ListException();
        if(isEmpty()){
            listArray[0] = newElement;
            curr = 0;
        }else {
            for (int i = numInList - 1; i > curr; i--) {
                listArray[i + 1] = listArray[i];
            }
            listArray[curr + 1] = (T) newElement;
            curr++;
        }
        //插入后要将光标右移
        numInList ++;
    }

    @Override
    public void remove() {
        if(isEmpty()) return;
        if(curr==numInList-1){
            curr = 0;
            numInList --;
            return;
        }
        for(int i=curr; i<numInList-1; i++){
            listArray[i] = listArray[i+1];
        }
        numInList--;
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        else if(newElement==null) return;
        else{
            listArray[curr] = newElement;
        }
    }

    @Override
    public void clear() {
        numInList = 0;
        curr = -1;
    }

    @Override
    public boolean isEmpty() {
        return numInList==0;
    }

    @Override
    public boolean isFull() {
        return numInList==msize;
    }

    @Override
    public boolean gotoBeginning() {
        if (!isEmpty()) {
            curr = 0;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoEnd() {
        if(!isEmpty()) {
            curr = numInList - 1;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty() || curr>=numInList - 1) return false;
        curr ++;
        return true;
    }

    @Override
    public boolean gotoPrev() {
        if (!isEmpty() && curr > 0) {
            curr--;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(!isEmpty()) {
            T currElem = (T) listArray[curr];
            return currElem;
        }
        return null;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {capacity = 512, length = "+numInList+", Cursor = " + curr+"}");//要用pw输出，而非System输出
        else{
            for (int i = 0; i < numInList; i++) {
                    pw.print(listArray[i]+" ");
            }
            pw.println("{capacity = " + msize + ", length = " + numInList + ",cursor = " + curr + "}");
        }
    }

    public void showLengthDCapacity(PrintWriter pw) {
        pw.print((double) numInList/msize + ",");
    }

    @Override
    public void moveToNth(int n) {
        if(numInList <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = listArray[curr];
        if(curr <= n){
            for(int i=curr;i < n;i++){
                listArray[i] = listArray[i+1];
            }
        }else {
            for(int i=n;i < curr;i++){
                listArray[i+1] = listArray[i];
            }
        }
        listArray[n] = temp;
        curr = n;
    }

    @Override
    public boolean find(T searchElement) {
        while(true){
            if(listArray[curr].equals(searchElement)){
                return true;
            }
            if(curr==numInList-1){
                return false;
            }
            curr++;
        }
    }
}
```

### 运行结果展示

与老师给的testcase完全相同，故此处不再展示。

## 链式实现

### 算法设计

#### `moveToNth`

若数组元素个数小于等于n，不符合操作前提，输出错误信息；

若数组元素个数大于等于n+1，通过调用一次删除操作和一次插入操作即可完成任务。

#### `find`

从curr所指的位置开始，让curr不断后移，直到搜索到目标元素或指向数组末尾。

### 主干代码分析

```java
import java.io.PrintWriter;

public class LListpro<T> implements List<T>{
    private class LinkedNode{
        T element;
        LinkedNode next;
        LinkedNode(T element, LinkedNode next){
            this.element = element;
            this.next = next;
        }
    }

    private LinkedNode dummy;
    private LinkedNode curr;
    private int length;
    LListpro() {
        curr = new LinkedNode(null, new LinkedNode(null, null));
        dummy = curr.next;
        length = 0;
    }


    @Override
    public void insert(T newElement){
        //漏掉了一种可能出现的情况，向空表添加元素，但不是在最初，而是通过若干步删除删成空表
        //此时，表中空无一物，但是curr==dummy而非在最初的"-1位置"
        if(newElement != null){
//            if(curr.next==null){
//                curr.next = new LinkedNode(newElement,null);
//            }
            if(isEmpty()){
                clear();
            }
            LinkedNode temp = curr.next.next;
            curr.next.next = new LinkedNode(newElement,temp);
            length++;
            curr = curr.next;
        }
    }

    @Override
    public void remove() {
        if(!isEmpty() && curr.next!=null){
            curr.next = curr.next.next;
            length--;
        }
        if(curr.next == null){
            curr = dummy;
        }
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        else if (newElement == null) {
            return;
        }else {
            curr.next.element = newElement;
        }
    }

    @Override
    public void clear() {
        curr = new LinkedNode(null, new LinkedNode(null, null));
        dummy = curr.next;
        length = 0;
    }

    @Override
    public boolean isEmpty() {
        return length==0;
    }

    @Override
    public boolean isFull() {
        return false;
    }

    @Override
    public boolean gotoBeginning() {
        if(!isEmpty()){
            curr = dummy;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoEnd() {
        if(!isEmpty()) {
            for (;curr.next!=null && curr.next.next != null; curr = curr.next) ;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty() || curr.next == null || curr.next.next == null) return false;
        curr = curr.next;
        return true;
    }

    @Override
    public boolean gotoPrev() {
        if(!isEmpty()){
            LinkedNode i = dummy;
            for(; i.next!=curr; i = i.next){
                if(i.next==null){
                    return false;
                }
            }
            curr = i;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(!isEmpty()){
            T currElem = curr.next.element;
            return currElem;
        }
        return null;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {length = "+length+", cursor = " + "-1" +"}");
        else {
            LinkedNode temp = dummy.next;
            int cursor = -1;
            for(int i = 0; i < length; i++, temp=temp.next){
                pw.print(temp.element + " ");
                if(curr.next == temp){
                    cursor = i;
                }
            }
            pw.println("{length = " + length + ",cursor = " + cursor + "}");
        }
    }

    @Override
    public void moveToNth(int n) {
        if(length <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = curr.next.element;
        remove();
        curr = dummy;
        for(int i=0; i<n-1; i++){
            curr = curr.next;
        }
        insert(temp);
    }

    @Override
    public boolean find(T searchElement) {
        curr = dummy;
        while(true){
            if(curr.next.element.equals(searchElement)){
                return true;
            }
            if(curr.next.next==null){
                return false;
            }
            curr = curr.next;
        }
    }
}
```

## 双向链表

### 算法设计

#### `moveToNth`

若数组元素个数小于等于n，不符合操作前提，输出错误信息；

若数组元素个数大于等于n+1，通过调用一次删除操作和一次插入操作即可完成任务。

#### `find`

从curr所指的位置开始，让curr不断后移，直到搜索到目标元素或指向数组末尾。

### 主干代码分析

```java
import java.io.PrintWriter;

public class DList<T> implements List<T>{
    private static class DLinkedNode<T>{
        DLinkedNode<T> prev;
        T element;
        DLinkedNode<T> next;
        public DLinkedNode(DLinkedNode<T> prev, T element, DLinkedNode<T> next){
            this.prev = prev;
            this.element = element;
            this.next = next;
        }
    }
    private int length;
    private DLinkedNode<T> head;
    private DLinkedNode<T> curr;
    public DList(){
        setup();
    }
    //独立setup方法
    private void setup(){
        head = new DLinkedNode<>(null,null,null);
        curr = new DLinkedNode<>(null, null, head);
        length = 0;
    }

    //不要只关注任务的完成，每次完成任务后一定要维护好数据间的关系不被破坏！
    //由于没有使用哑结点技术，所以在插入和删除时要分情况讨论。
    @Override
    public void insert(T newElement){
        if(newElement==null) return;
        if(isEmpty()) clear();
        if(isEmpty()){
            head = curr = new DLinkedNode<>(null,newElement,null);
        } else {
            curr.next = new DLinkedNode<>(curr, newElement, curr.next);
            if(curr.next.next!=null) {
                curr.next.next.prev = curr.next;
            }
            curr = curr.next;
        }
        length++;
    }

    //判断条件的书写一定要三思，同时要注意利用逻辑符号的短接性质来避免产生错误。
    @Override
    public void remove() {
        if(isEmpty() || length == 1){
            clear();
            return;
        } else if(curr == head && head.next!=null){
            head = curr = head.next;
            head.prev = null;
        } else if(curr.next == null && curr.prev!=null){
            curr.prev.next = null;
            curr = head;
        }
        else if(curr.next!=null && curr.prev != null){
            DLinkedNode del = curr;
            DLinkedNode delPrev = curr.prev;
            DLinkedNode delNext = curr.next;
            delPrev.next = curr.next;
            delNext.prev = curr.prev;
            curr = delNext;
        }
        length--;
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        if(curr==null) return;
        if(newElement==null) return;
        curr.element = newElement;
    }

    @Override
    public void clear() {
        setup();
    }

    @Override
    public boolean isEmpty() {
        return length==0;
    }

    @Override
    public boolean isFull() {
        return false;
    }

    //移动指针一定要根据接口的要求来移动，并且要注意程序的鲁棒性。
    @Override
    public boolean gotoBeginning() {
        if(!isEmpty()){
           curr = head;
        }
        return true;
    }

    @Override
    public boolean gotoEnd() {
        if(isEmpty()) return false;
        while(curr!=null && curr.next!=null) curr=curr.next;
        return true;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty()) return false;
        if(curr!=null && curr.next!=null){
            curr = curr.next;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoPrev() {
        if(isEmpty()) return false;
        if(curr!= null && curr.prev!=null){
            curr = curr.prev;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(isEmpty()) return null;
        return curr.element;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {length = "+length+", cursor = " + "-1" +"}");
        else {
            int cursor = -2;
            DLinkedNode temp = head;
            if(curr==head){
                cursor = -1;
            }
            int i=-1;
            while(temp!=null){
                i++;
                if(temp==curr){
                    cursor = i;
                }
                pw.print(temp.element + " ");
                temp = temp.next;
            }
            pw.println("{length = " + length + ",cursor = " + cursor + "}");
        }
    }

    @Override
    public void moveToNth(int n) {
        if(length <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = curr.element;
        remove();
        curr = head;
        for(int i=0; i<n-1; i++){
            curr=curr.next;
        }
        insert(temp);
    }

    @Override
    public boolean find(T searchElement) {
        if(isEmpty()) return false;
        curr = head;
        while(true){
            if(curr.element.equals(searchElement)){
                return true;
            }
            if(curr.next==null){
                return false;
            }
            curr = curr.next;
        }
    }
}
```

## 总结与收获

这道题写了整整一周，真的是有很多刻骨铭心的记忆。

找bug的时候可以试试：

1. 增加输出语句，不要嫌麻烦，把能输出的东西全部都输出出来，总能找到问题的！
2. 把一部分代码注释掉看看还有没有报错（但这种方法非常不准，只能粗略估计一下，因为有的时候报错的是A，注释掉B之后就可以运行了，但是真正出错的地方却是C）。
3. 想特殊情况（不要以为你已经考虑过了，事实上就是会有一些奇怪的情况会被遗漏），比如链表初始时curr指向-1位置，但是一直用remove去删到空的时候curr指向的却是0位置，每次在怀疑是否是特殊情况错了的时候都会推一遍，但从来没有想到过有这种情况。
4. 用调试功能一条一条执行，很慢，但确实能找出来。
5. 重写一遍吧兄弟，也许有效果呢。

宗旨就是不要急，不要想着拆东墙补西墙糊过去，代码是没有同情心的，一直盯着看或者无组织无计划的空想绝对不是解决问题的好办法。灵感来的时候确实可以很快解决问题，但来的概率也太小了，不如踏踏实实去找问题吧。

（真的执行出来的那一刻，快要忍不住在图书馆大叫了。）

# 任务2

## 题目：创建一个可自动调整空间大小的 List 数据结构 

![70203838397](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1702038383976.png)

![70203839640](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1702038396400.png)

## 算法分析

初始时`capacity`的值为1

若 `length == capacity` 则调用 `setup` 方法创建一个新的数组，该数组的 `capacity` 值为原来的2倍。

将原来的元素拷贝的新的数组中，将新的数组作为这个结构的成员进行存储。

删除元素时，增加判断 `length <= capacity / 4` ，若满足该条件，则调用 `setup` 方法创建一个新的 `capacity = capacity / 2` 的数组。

将原来的元素拷贝的新的数组中，将新的数组作为这个结构的成员进行存储。

使用任务1中的 `ListTest` 类对该数据结构进行测试。

将测试结果中的length和capacity的比值和用普通数组测试得到的比值进行记录。

使用上次实验中的折线图绘制类进行展示。

## 主干代码分析

```java
import java.io.PrintWriter;

public class ResizingAList<T> implements List<T>{
    private int capacity = 1;
    private int length;
    private int curr;
    private T[] listArray;

    ResizingAList(){
        listArray = setup(capacity);
        length = 0;
        curr = -1;
    }
    private T[] setup(int size){
        capacity = size;
        return (T[]) new Object[size];
    }

    private void swell(){
        T[] newArray = setup(2*capacity);
        for(int i=0; i<length; i++){
            newArray[i] = listArray[i];
        }
        listArray = newArray;
    }

    private void shrink(){
        T[] newArray = setup(capacity / 2);
        for(int i = 0; i < length; i ++){
            newArray[i] = listArray[i];
        }
        listArray = newArray;
    }

    @Override
    public void insert(T newElement){
        if (isFull()){
            swell();
        }
        if(isEmpty()){
            listArray[0] = newElement;
            curr = 0;
        }else {
            for (int i = length - 1; i > curr; i--) {
                listArray[i + 1] = listArray[i];
            }
            listArray[curr + 1] = (T) newElement;
            curr++;
        }
        //插入后要将光标右移
        length ++;
    }

    @Override
    public void remove() {
        if(isEmpty()) return;
        if(curr==length-1){
            curr = 0;
            length --;
            return;
        }
        for(int i=curr; i<length-1; i++){
            listArray[i] = listArray[i+1];
        }
        length--;
        if(length <= capacity/4){
            shrink();
        }
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        else if(newElement==null) return;
        else{
            listArray[curr] = newElement;
        }
    }

    @Override
    public void clear() {
        length = 0;
        curr = -1;
    }

    @Override
    public boolean isEmpty() {
        return length==0;
    }

    @Override
    public boolean isFull() {
        return length==capacity;
    }

    @Override
    public boolean gotoBeginning() {
        if (!isEmpty()) {
            curr = 0;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoEnd() {
        if(!isEmpty()) {
            curr = length - 1;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty() || curr>=length - 1) return false;
        curr ++;
        return true;
    }

    @Override
    public boolean gotoPrev() {
        if (!isEmpty() && curr > 0) {
            curr--;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(!isEmpty()) {
            T currElem = (T) listArray[curr];
            return currElem;
        }
        return null;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {capacity = 512, length = "+length+", Cursor = " + curr+"}");//要用pw输出，而非System输出
        else{
            for (int i = 0; i < length; i++) {
                    pw.print(listArray[i]+" ");
            }
            pw.println("{capacity = " + capacity + ", length = " + length + ",cursor = " + curr + "}");
        }
    }

    public void showLengthDCapacity(PrintWriter pw) {
        pw.print((double)length/capacity + ",");
    }

    @Override
    public void moveToNth(int n) {
        if(length <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = listArray[curr];
        if(curr <= n){
            for(int i=curr;i < n;i++){
                listArray[i] = listArray[i+1];
            }
        }else {
            for(int i=n;i < curr;i++){
                listArray[i+1] = listArray[i];
            }
        }
        listArray[n] = temp;
        curr = n;
    }

    @Override
    public boolean find(T searchElement) {
        while(true){
            if(listArray[curr].equals(searchElement)){
                return true;
            }
            if(curr==length-1){
                return false;
            }
            curr++;
        }
    }
}
```

## 测试代码展示

```java
import java.io.*;

public class ListTest {
    public static void main(String[] args) throws IOException, ListException {
        FileReader fis = new FileReader("list_testcase.txt");
        BufferedReader br = new BufferedReader(fis);
        StreamTokenizer st = new StreamTokenizer(br);
        st.eolIsSignificant(true);
        PrintWriter pw = new PrintWriter("resizingalist_test_result2.txt");
//        List<Character> characterList = new AList<>();
        List<Character> characterList = new ResizingAList<>();
        //List<Character> characterList = new LList<>();
        //List<Character> characterList = new DList<>();
        int token = st.nextToken();
        while (token != StreamTokenizer.TT_EOF){
            char command = (char)st.ttype;
            switch(command){
                case '+' :{
                    st.nextToken();
                    characterList.insert(st.sval.charAt(0));
                    break;
                }
                case '-' :{
                    characterList.remove();
                    break;
                }
                case '=' :{
                    st.nextToken();
                    characterList.replace(st.sval.charAt(0));
                    break;
                }
                case '#' :{
                    characterList.gotoBeginning();
                    break;
                }
                case '*' :{
                    characterList.gotoEnd();
                    break;
                }
                case '>' :{
                    characterList.gotoNext();
                    break;
                }
                case '<' :{
                    characterList.gotoPrev();
                    break;
                }
                case '~' :{
                    characterList.clear();
                    break;
                }
            }
            if(token == StreamTokenizer.TT_EOL || (char) token == '\n'){
                characterList.showLengthDCapacity(pw);
                pw.flush();
//                characterList.clear();
            }
            token = st.nextToken();
        }
//        characterList.showStructure(pw);
        characterList.showLengthDCapacity(pw);
        pw.flush();
        characterList.clear();//需要在文件结束后再做一次输出，因为最后一行的结尾并没有EOL
        pw.close();
        fis.close();
        br.close();
    }
}
```

## 运行结果展示

AList运行结果：

> 0.025390625,0.037109375,0.056640625,0.08984375,0.03515625,0.037109375,0.015625,0.056640625,0.091796875,0.02734375,0.080078125,0.01953125,0.0625,0.1015625,0.025390625,0.076171875,0.099609375,0.13671875,0.001953125,0.00390625,0.041015625,0.087890625,0.12890625,0.0,0.041015625,0.08203125,0.1328125,0.005859375,0.02734375,0.044921875,0.078125,0.123046875,0.0,0.037109375,0.072265625,0.115234375,0.03515625,0.083984375,0.046875,0.029296875,0.05859375,0.095703125,0.119140625,0.162109375,0.1953125,0.013671875,0.009765625,0.052734375,0.0859375,0.12109375,0.162109375,0.013671875,0.056640625,0.09375,0.130859375,0.16015625,0.185546875,0.228515625,0.01953125,0.0546875,0.08203125,0.115234375,0.14453125,0.19921875,0.248046875,0.275390625,0.3125,0.0078125,0.029296875,0.041015625,0.033203125,0.04296875,0.08203125,0.125,0.15625,0.212890625,0.2421875,0.28125,0.318359375,0.36328125,0.38671875,0.421875,0.46875,0.51171875,0.54296875,0.58984375,0.623046875,0.6484375,0.02734375,0.021484375,0.052734375,0.046875,0.015625,0.0546875,0.072265625,0.111328125,0.13671875,0.0,0.029296875,0.033203125,0.060546875,0.091796875,0.13671875,0.009765625,0.0078125,0.037109375,0.08984375,0.119140625,0.15625,0.015625,0.0078125,0.048828125,0.00390625,0.044921875,0.076171875,0.09375,0.13671875,0.189453125,0.23828125,0.00390625,0.05078125,0.08984375,0.1484375,0.001953125,0.01171875

ResizingAList运行结果：

> 0.8125,0.59375,0.90625,0.71875,0.5625,0.59375,0.5,0.90625,0.734375,0.21875,0.640625,0.625,1.0,0.8125,0.8125,0.609375,0.796875,0.546875,0.015625,0.25,0.65625,0.703125,0.515625,0.0,0.65625,0.65625,0.53125,0.0234375,0.4375,0.71875,0.625,0.984375,0.0,0.59375,0.578125,0.921875,0.5625,0.671875,0.75,0.9375,0.9375,0.765625,0.953125,0.6484375,0.78125,0.0546875,0.3125,0.84375,0.6875,0.96875,0.6484375,0.21875,0.90625,0.75,0.5234375,0.640625,0.7421875,0.9140625,0.15625,0.4375,0.65625,0.921875,0.578125,0.796875,0.9921875,0.55078125,0.625,0.0625,0.9375,0.65625,0.53125,0.6875,0.65625,0.5,0.625,0.8515625,0.96875,0.5625,0.63671875,0.7265625,0.7734375,0.84375,0.9375,0.51171875,0.54296875,0.58984375,0.623046875,0.6484375,0.4375,0.6875,0.84375,0.75,0.5,0.875,0.578125,0.890625,0.546875,0.0,0.9375,0.53125,0.96875,0.734375,0.546875,0.0390625,0.125,0.59375,0.71875,0.953125,0.625,0.125,0.0625,0.78125,0.0625,0.71875,0.609375,0.75,0.546875,0.7578125,0.953125,0.0625,0.8125,0.71875,0.59375,0.0625,0.75

通过图像展示如下：

![70290053791](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1702900537918.png)

## 总结与收获

从图像中可以看出，ResizingAList的空间利用率在绝大多数时候都远高于普通的AList数组。因此，这种优化可以在一定程度上缓解数组存储方式空间利用率过低的问题。但需要注意的是，这种优化方式是有时间代价的，每次变化数组的长度时，需要将元素通过遍历一个一个复制到新的数组中，会产生不少的时间代价。这也体现了“时间与空间代价此消彼长，相互平衡”的道理。

# 任务3：栈

## 对递归快速排序的非递归转化

递归是一种解决很多复杂问题最简单的思想方法，而任何编程语言对递归程序的支持都是通过栈实现的。请利用课堂上讲解的“ Hanoi 塔”问题的非递归转化方法完成对递归快速排序的非递归转化。

### 知识回顾：将递归改为递推的通用方法

```java
/*
    创建一个TOHOBJ数据类型
    有以下数据：
    1. n
    2. s
    3. t
    4. g
    5. OperationType: TOH/move
    建立栈，将总任务压入栈中
     */
    stack.push(总任务);
    while(!stack.isEmpty()){
        当前任务 = stack.pop();
        if(当前任务 == move){
            move(当前任务.s, 当前任务.g);
        } else {
            stack.push(子任务3);
            stack.push(子任务2);
            stack.push(子任务1);
            //先压入栈的任务后执行
            //子任务3：n = n - 1; s = t; t = s; g = g; OperationType = TOH;
            //另外两个子任务也类似
        }
    }
```

### 算法设计

将快速排序的标志性递推结构提取出来

创建一个`QuickSortOBJ`类，该类包含以下数据：

```java
private Comparable[] objs;
private int low;
private int high;
private int operationType;
```

快速排序主干的递归是这样写的：

```java
int pivotIndex = partition(objs, low, high);
quick(objs, low, pivotIndex-1);
quick(objs, pivotIndex+1, high);
```

通过课堂上的套路，可以把这个主干变成：

1. 建立一个栈

2. 向栈中压入对整个数组排序的任务

3. 当栈不空时，循环下面的操作：

   弹栈，对弹出的任务进行分析：

   1. 若此时达到递归基准情形，则不再操作，但不是结束程序，而是处理下一个栈中的任务
   2. 若此任务为划分任务，则进行划分操作
   3. 若此任务为快速排序任务，则将三个子任务倒序压入栈中

4. 程序结束，排序完毕！

### 主干代码分析

为了保证指代清晰，分析写在了代码旁的注释中

```java
import 准备工作.LStack;
public class QuickSortStack extends SortAlgorithm{

    //在主函数中写一些用于测试的代码
    public static void main(String[] args){
        int[] testList = {1,2,3,4,5,6,7,7,6,5,4,3,2,1};
        Integer[] test = new Integer[14];
        for (int i = 0; i < 14; i++) {
            test[i] = (Integer) testList[i];
        }
        QuickSortStack qss = new QuickSortStack();
        qss.quick(test, 0, test.length-1);
        for (Integer i :
                test) {
            System.out.print(i + " ");
        }
    }
    //对quick进行的封装，使参数表更简洁
    public void sort(Comparable[] objs) {
        int N = objs.length;
        quick(objs, 0, N - 1);
    }
    //内部类QuickSortOBJ,是一个存储工作块信息的数据类型
    public class QuickSortOBJ {
        private Comparable[] objs;
        private int low;
        private int high;
        private int operationType;
        //构造函数
        public QuickSortOBJ(Comparable[] objs, int low, int high, int operationType){
            this.low = low;
            this.objs = objs;
            this.high = high;
            this.operationType = operationType;
            //0:quicksort
            //1:partition
        }
    }
    //快速排序的主干代码
    public void quick(Comparable[] objs, int low, int high){
        LStack QSLStack = new LStack();
        QuickSortOBJ currTask = new QuickSortOBJ(objs,low,high,0);
        QSLStack.push(currTask);
        //这些之前每轮都要迭代的变量应该放到循环外面进行声明
        int pivotIndex = low;
        while(!QSLStack.isEmpty()){
            currTask = (QuickSortOBJ) QSLStack.pop();
            if (currTask.low >= currTask.high) {
                continue;//这里不应该return，而应该continue!
            }
            if(currTask.operationType == 1){
                pivotIndex = partition(currTask.objs, currTask.low, currTask.high);
            } else {
                QSLStack.push(new QuickSortOBJ(currTask.objs, pivotIndex+1, currTask.high, 0));
                QSLStack.push(new QuickSortOBJ(currTask.objs, currTask.low, pivotIndex-1, 0));
                QSLStack.push(new QuickSortOBJ(currTask.objs, currTask.low, currTask.high, 1));
            }
        }
    }

    //沿用了上一次实验的轴值选择方法：三值选中法
    private Comparable choosePivot(Comparable[] objs, int low, int high){
        int mid = low + (high - low) / 2;
        Comparable pivot = objs[high];
        if (!(less(objs[low], objs[high]) ^ less(objs[mid], objs[low]))) {
            pivot = objs[low];
            exchange(objs, low, high);
        } else if (!(less(objs[mid], objs[low]) ^ less(objs[high], objs[mid]))) {
            pivot = objs[mid];
            exchange(objs, mid, high);
        }
        return pivot;
    }

    //双路划分
    private int partition(Comparable[] objs, int left, int right){
        Comparable pivot = choosePivot(objs,left,right);
        //循环不变量：
        //[left..i) < pivot
        //(j..right-1] > pivot
        int i = left;
        int j = right-1;
        while(i <= j){
            while(i<=j && less(objs[i],pivot)){ // i找大于等于轴值的值，因此在小于轴值时要向右移动
                i++;
            }
            while(i<=j && less(pivot,objs[j])){ // j找小于等于轴值的值，因此在大于轴值时要向左移动
                j--;
            }
            if(i<=j){
                exchange(objs,i,j);
                i++;
                j--;
            }
        }
        exchange(objs,i,right);
        return i;
    }
}
```

### 运行结果展示

![70257309862](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1702573098620.png)

在实际测试时，不只使用了这一组数据，但限于篇幅，此处只放上一张截图。

## 算术混合运算表达式的计算

表达式不仅能处理整数，还需要处理小数。表达式中涉及的运算符包括+、 -、 *、 /、 ^(指数)。表达式可以包含括号（只包含圆括号） 嵌套，因此要处理括号匹配失败的情形。

### 算法设计

设置两个栈：一个是操作符栈`opStack`，另一个是操作数栈`numStack`。

扫描当前表达式，若为操作数，则入栈，若为操作符，进行下面的操作：

当当前操作符为 `)` 时，逐次弹栈计算，直到遇到 `(` 弹栈为止，若已经到底而没有遇到 `(` ，则说明右括号冗余，输出错误信息；

当当前的操作符优先级大于操作符栈栈顶操作符时，将此操作符压栈；

小于时，将栈中符号弹出，并弹出相应数目的操作数，进行计算，并将计算结果压入栈中；

> 具体来说，+ - * / ^ 均为双目运算符，应该弹出两个元素进行计算，且后弹出的元素在前，先弹出的元素在后。

等于时，通过结合性判断，左结合——按小于处理，右结合——按大于处理。

最终从操作符栈中弹出操作符，并进行计算操作。如果在弹出过程中遇到 `(` ，则说明左括号冗余，输出错误信息。

最终栈里留下的数字即为运算结果。

### 数据设计与代码分析

两个栈都要用链式存储结构进行实现。

对操作符优先级和结合性的判断和存储：

可以创建一种数据结构 `Operator` 来存储操作符

在这个数据结构中，可以通过整型来表达优先级：

规定：

1. `+` `-` 的优先级为10
2. `*` `/` 的优先级为100
3. `^` 的优先级为1000
4. `(` 在入栈前的优先级为10000，在入栈后的优先级为1（可以通过开放一个方法，在入栈时进行修改）

可以通过布尔值来表达结合性：

规定：

1. `true` 为右结合
2. `false` 为左结合

在输出错误信息时，这里使用了自定义异常的方法，在抛出错误时，顺便将错误的信息通过 `InputException` 的 `message` 成员变量进行记录，在main函数中统一处理。

这种实现的不足之处：只能处理单个字符表示的运算符，不能处理 `sqrt` 等运算符，但这种操作可以通过调用库中的函数来实现，也不需要加入“运算符”的概念当中来。

### 主干代码分析

```java
import 准备工作.LStack;
import java.util.Scanner;

public class Calculate {
    public static void main(String[] args){
        //提示用户输入
        System.out.println("------------------------------------------------------------------------");
        System.out.println("Please input an arithmetic expression, split every character with space:");

        //读取用户输入
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();

        //进行计算操作
        Calculate cal = new Calculate();
        try {
            System.out.println("= " + cal.calculate(input));
        } catch (InputException e) {
            System.out.println(e.message);
        }
        System.out.println("------------------------------------------------------------------------");
    }

    public double calculate(String input) throws InputException {
        //创建两个栈
        LStack<Operator> opStack = new LStack<>();
        LStack<Double> numStack = new LStack<>();

        //分割字符串
        String[] sList = input.split(" ");

        //创建一些公用的变量
        Operator temp;
        char curr;

        //进行计算操作
        for (String s :
                sList) {
            try {
                numStack.push(Double.parseDouble(s));
            } catch (Exception e){
                if(s.length() == 1 && isValidOperator(s.charAt(0))){
                    curr = s.charAt(0);
                    if(curr == ')'){
                        while((temp = opStack.pop()).operator != '('){
                            operate(temp,numStack);
                            //检查括号不匹配现象
                            if(opStack.isEmpty()){
                                throw new InputException("There is a redundant ')'!");
                            }
                        }
                    } else {
                        //创建一个操作符对象
                        temp = new Operator(curr);
                        if (!opStack.isEmpty() && (temp.precedence <= opStack.topValue().precedence) && ((temp.precedence != opStack.topValue().precedence) || !temp.associativity)) {
                            while (temp.precedence < opStack.topValue().precedence || (temp.precedence == opStack.topValue().precedence && !temp.associativity)) {
                                operate(opStack.pop(), numStack);
                                if (opStack.isEmpty()) break;
                            }
                        }
                        //入栈时调用bracketInStack()方法来修改左括号的优先级
                        temp.bracketInStack();
                        opStack.push(temp);
                    }
                } else {
                    throw new InputException("Input Error!");
                }
            }
        }

        //进行最终的计算操作
        while(!opStack.isEmpty()){
            temp = opStack.pop();
            //判断左括号是否冗余
            if(temp.operator == '('){
                throw new InputException("There is a redundant '('!");
            }
            operate(temp, numStack);
        }

        return numStack.topValue();
    }

    //将具体的计算单独写成一个方法
    private void operate(Operator curr, LStack<Double> numStack){
        double x2 = numStack.pop();
        double x1 = numStack.pop();
        switch (curr.operator) {
            case '+' -> numStack.push(x1 + x2);
            case '-' -> numStack.push(x1 - x2);
            case '*' -> numStack.push(x1 * x2);
            case '/' -> numStack.push(x1 / x2);
            case '^' -> numStack.push(Math.pow(x1, x2));
        }
    }

    //判断是否是有效的操作符
    public boolean isValidOperator(char operator){
        return operator == '+' || operator == '-'
                || operator == '^' || operator == '*'
                || operator == '/' ||operator == '('
                || operator == ')' ;
    }
}
```

```java
public class InputException extends Throwable{
    String message;
    InputException(){}
    InputException(String message){
        this.message = message;
    }
}
```

```java
public class Operator {
    //操作符数据结构
    char operator;
    int precedence;
    boolean associativity;

    public Operator(){}

    public Operator(char operator){
        this.operator = operator;
        this.precedence = precedence(operator);
        this.associativity = associativity(operator);
    }

    private int precedence(char operator){
        if(operator == '+' || operator == '-'){
            return 10;
        } else if (operator == '^') {
            return 1000;
        } else if(operator == '*' || operator == '/'){
            return 100;
        } else if (operator == '(') {
            return 10000;
        } else {
            System.out.println("Not a valid operator!");
            return 0;
        }
    }

    private boolean associativity(char operator){
        if(operator == '^'){
            return true;
        }
        return false;
    }

    public void bracketInStack(){
        if(this.operator == '('){
            this.precedence = 1;
        }
    }
}
```



### 运行结果展示

![70312605981](C:\Users\95801\Desktop\算术混合运算表达式的计算.assets\1703126059816.png)

![70312616819](C:\Users\95801\Desktop\算术混合运算表达式的计算.assets\1703126168191.png)

![70312662484](C:\Users\95801\Desktop\算术混合运算表达式的计算.assets\1703126624842.png)

![70312664883](C:\Users\95801\Desktop\算术混合运算表达式的计算.assets\1703126648838.png)

![70312666645](C:\Users\95801\Desktop\算术混合运算表达式的计算.assets\1703126666454.png)

## 设计 `LeakyStack` 数据结构

当我们在使用很多软件时都有类似“ undo”功能，比如 Web 浏览器的回退功能、文本编辑器的撤销编辑功能。这些功能都可以使用Stack 简单实现，但是在现实中浏览器的回退功能也好，编辑器的撤销功能也好，都有一定的数量限制。因此我们需要的不是一个普通的 Stack 数据结构，而是一个空间有限制的 Stack，虽然空间有限，但这样的 Stack 在入栈时从不会溢出，因为它会采用将最久远的记录丢掉的方式让新元素入栈，也就是说总是按照规定的数量要求保持最近的历史操作。比如栈的空间是 5，当 a\b\c\d\e 入栈之后，如果继续让元素 f 入栈，那么栈中的元素将是 b\c\d\e\f。请设计一个满足上面要求的 LeakyStack 数据结构，要求该数据结构的每一个操作的时间复杂度在最坏情形下都必须满足 O(1)。 

### 算法设计

这种数据结构要求对数据的首和尾均能实现操作，一旦栈满，就会把元素往出顶，不禁使我联想到在羽毛球筒中塞羽毛球的操作，或者说，队列的操作。也就是说，单看Leak的操作，是先入先出的。另外，它还要满足栈的特征——栈顶可以出入栈。因此，可以尝试采用循环数组进行实现。

#### 基本设计思想、初始化操作与清空操作

开始时创建一个size为capacity+1的数组，front指针指向栈顶的前一个位置，rear初始化为front。

#### 入栈操作

先将元素放入front所指的位置

front=(front-1+size)%size，将front前移

#### 出栈操作

front=(front+1) % size，将front后移

返回目前front所指的元素

#### 判断栈满

(rear + 1) % size == front

#### 判断栈空

rear == front

#### 漏出操作

如果栈满，则将rear前移，即rear = (rear-1+size) % size

可以将这个操作直接与`push`操作融合，减少一次方法调用的开销。

#### 计算元素个数

length = (rear - front + size) % size

#### toString方法

通过遍历元素进行输出

### 主干代码分析

```java
public class LeakyStack<T> {
    private static final int DEFAULT_SIZE = 6;
    private int size = 6;
    private int front;
    private int rear;
    private T[] listArray;
	
    //构造方法
    LeakyStack(){
        setup(DEFAULT_SIZE);
    }
    LeakyStack(int capacity){
        setup(capacity+1);
    }
    //独立setup方法
    private void setup(int size){
        this.size = size;
        listArray = (T[]) new Object[size];
        front = 0;
        rear = 0;
    }

    public boolean isFull(){
        if((rear + 1) % size == front){
            return true;
        }
        return false;
    }

    public boolean isEmpty(){
        if(rear == front){
            return true;
        }
        return false;
    }

    /**
     * Push newELement into LeakyStack,
     * and return whether a certain element leaking from the Stack.
     * @param newElement
     * @return "true" if something leaked out
     */
    public boolean push(T newElement){
        boolean flag = false;
        if(isFull()){
            rear = (rear-1+size) % size;
            flag = true;
        }
        //这里先进行Leak和后进行Leak是很有讲究的，
        //如果先push再判断栈满的话，刚刚满的栈就会漏出一个元素，变得不满
        //这样的话push操作后栈永远满不了，而是只能处在“剩一个元素”的状态
        //这样本质上会让栈的容量-1
        listArray[front] = newElement;
        front = (front-1+size) % size;
        return flag;
    }

    /**
     * Pop the element at the top of the stack.
     * @return the popped element
     */
    public T pop(){
        if(!isEmpty()){
            front = (front+1) % size;
            return listArray[front];
        }
        return null;
    }

    /**
     * Get the value of the element at the top of the stack.
     * @return value of that element
     */
    public T topValue(){
        return listArray[(front+1)%size];
    }

    public void clear(){
        setup(size);
    }

    public int length(){
        return (rear - front + size) % size;
    }

    //用StringBuilder来构造输出的字符串
    @Override
    public String toString() {
        if(isEmpty()){
            return "Empty Stack!";
        }
        {
            StringBuilder out = new StringBuilder((length() + 1) * 4);
            out.append("< ");
            for (int i = (front+1)%size; i!=rear; i=(i+1)%size) {
                out.append(listArray[i]);
                out.append(" ");
            }
            out.append(listArray[rear]);
            out.append(" ");
            out.append(">");
            out.append(" {numInStack = ");
            out.append(length());
            out.append("}");
            return out.toString();
        }
    }

    //测试代码
    public static void main(String[] args){
        LeakyStack<Integer> numLS = new LeakyStack<>(6);
        numLS.push(1);
        System.out.println(numLS);
        numLS.push(2);
        System.out.println(numLS);
        numLS.push(3);
        System.out.println(numLS);
        numLS.push(4);
        System.out.println(numLS);
        numLS.push(5);
        System.out.println(numLS);
        numLS.push(6);
        System.out.println(numLS);
        numLS.push(7);
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.clear();
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.push(7);
        System.out.println(numLS);
        numLS.push(8);
        System.out.println(numLS);
        numLS.push(9);
        System.out.println(numLS);
        numLS.push(10);
        System.out.println(numLS);
        numLS.push(11);
        System.out.println(numLS.topValue());
        System.out.println(numLS);
    }
}
```

### 运行结果展示

![70304446164](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1703044461649.png)

### 时间复杂度分析

除输出时的toString方法需要遍历外，由于每个操作都只是对指针的一次移动，或者再附加一次对数组某个下标对应元素的赋值，甚至只是一些简单的计算，所以他们的时间复杂度都是O(1)，满足题目的要求。

## 总结与收获

通过对三个任务的完成，我切身体会到了栈这种数据结构的强大功能，还体会到了数据结构和存储技术对应的多样性。条件稍微发生改变，方法的实现，存储结构的使用就会大有不同。



# 任务四：基数排序

## 题目

使用自定义的队列数据结构实现对某一个数据序列的排序(采用基数排序)，其中对待排序数据有如下的要求：

①当数据序列是整数类型的数据的时候，数据序列中每个数据的位数不要求等宽，比如: 1、21、 12、 322、 44、 123、 2312、 765、 56

② 当数据序列是字符串类型的数据的时候，数据序列中每个字符串都是等宽的，比如 : abc","bde","fad","abd","bef","fdd","abe"

注： radixsort1.txt 和 radixsort2.txt 是为上面两个数据序列提供的测试数据。

## 队列的实现

### ADT与接口

```java
public interface Queue<T> {
    public void clear();
    public void enqueue(T newElement);
    public T dequeue();
    public T firstValue();
    public boolean isEmpty();
    public int length();
}
```

### AQueue的实现

```java
public class AQueue<T> implements Queue<T> {
    private static final int DEFAULT_SIZE = 6;
    private int size = 6;
    private int front;
    private int rear;
    private T[] listArray;

    //构造函数
    AQueue(){
        setup(DEFAULT_SIZE);
    }
    AQueue(int capacity){
        setup(capacity+1);
    }
    //独立setup方法
    private void setup(int size){
        this.size = size;
        listArray = (T[]) new Object[size];
        front = 0;
        rear = 0;
    }

    public boolean isFull(){
        if((rear + 1) % size == front){
            return true;
        }
        return false;
    }

    public boolean isEmpty(){
        if(rear == front){
            return true;
        }
        return false;
    }

    public void clear(){
        setup(size);
    }

    //入队操作
    @Override
    public void enqueue(T newElement) {
        if(!isFull()) {
            rear = (rear + 1) % size;
            listArray[rear] = newElement;
        }
    }

    //出队操作
    @Override
    public T dequeue() {
        if(!isEmpty()){
            front = (front + 1) % size;
        }
        return null;
    }

    //首元素值的读取
    @Override
    public T firstValue() {
        return listArray[(front+1)%size];
    }

    public int length(){
        return (rear - front + size) % size;
    }

    //使用StringBuider进行字符串构建
    @Override
    public String toString() {
        if(isEmpty()){
            return "Empty Queue!";
        }
        {
            StringBuilder out = new StringBuilder((length() + 1) * 4);
            out.append("< ");
            for (int i = (front+1)%size; i!=rear; i=(i+1)%size) {
                out.append(listArray[i]);
                out.append(" ");
            }
            out.append(listArray[rear]);
            out.append(" ");
            out.append(">");
            out.append(" {numInQueue = ");
            out.append(length());
            out.append("}");
            return out.toString();
        }
    }

    //一些测试代码
    public static void main(String[] args){
        AQueue<Integer> numLS = new AQueue<>(6);
        numLS.enqueue(1);
        System.out.println(numLS);
        numLS.enqueue(2);
        System.out.println(numLS);
        numLS.enqueue(3);
        System.out.println(numLS);
        numLS.enqueue(4);
        System.out.println(numLS);
        numLS.enqueue(5);
        System.out.println(numLS);
        numLS.enqueue(6);
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.clear();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.enqueue(8);
        System.out.println(numLS);
        numLS.enqueue(9);
        System.out.println(numLS);
        numLS.enqueue(10);
        System.out.println(numLS);
        numLS.enqueue(11);
        System.out.println(numLS.firstValue());
        System.out.println(numLS);
    }
}
```

#### 运行结果展示

![70307507850](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1703075078509.png)

### LQueue的实现

#### 设计

front只需要进行删除，rear只需要进行插入，所以front可以指向链表的头部，rear可以指向链表的尾部。

这样的话也无需使用哑结点。

#### 实现

```java
public class LQueue<T> implements Queue<T>{
    //内部类LinkedNode
    private static class LinkedNode<T>{
        T element;
        LinkedNode<T> next;
        public LinkedNode(T element , LinkedNode<T> next){
            this.element = element;
            this.next = next;
        }
    }

    //定义front, rear, length
    private LinkedNode<T> front;
    private LinkedNode<T> rear;
    private int length;

    //constructor
    public LQueue(){
        front = null;
        rear = null;
        length = 0;
    }
    
    //清空队列
    @Override
    public void clear() {
        front = rear = null;
        length = 0;
    }

    //入队操作
    @Override
    public void enqueue (T newElement) {
        if(isEmpty()){
            front = rear = new LinkedNode<T>(newElement,null);
        } else {
            rear.next = new LinkedNode<T>(newElement,null);
            rear = rear.next;
        }
        length++;
    }

    //出队操作
    @Override
    public T dequeue() {
        if(!isEmpty()) {
            LinkedNode<T> temp = front;
            front = front.next;
            length--;
            return temp.element;
        }
        return null;
    }

    //读取首元素
    @Override
    public T firstValue() {
        if(isEmpty()) return null;
        return front.element;
    }

    //判空
    @Override
    public boolean isEmpty() {
        return length==0;
    }

    //判满
    @Override
    public boolean isFull(){
        return false;
    }

    //队长
    @Override
    public int length() {
        return length;
    }

    public String toString()
    {
        if(isEmpty()) return "Empty Queue!";
        StringBuilder out = new StringBuilder((length() + 1) * 4);
        LinkedNode<T> temp = front;
        out.append("< ");
        while(temp != null){
            out.append(temp.element);
            out.append(" ");
            temp = temp.next;
        }
        out.append(">");
        return out.toString();
    }

    //一些测试代码
    public static void main(String[] args){
        LQueue<Integer> numLS = new LQueue<>();
        numLS.enqueue(1);
        System.out.println(numLS);
        numLS.enqueue(2);
        System.out.println(numLS);
        numLS.enqueue(3);
        System.out.println(numLS);
        numLS.enqueue(4);
        System.out.println(numLS);
        numLS.enqueue(5);
        System.out.println(numLS);
        numLS.enqueue(6);
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.clear();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.enqueue(8);
        System.out.println(numLS);
        numLS.enqueue(9);
        System.out.println(numLS);
        numLS.enqueue(10);
        System.out.println(numLS);
        numLS.enqueue(11);
        System.out.println(numLS.firstValue());
        System.out.println(numLS);
    }
}
```

#### 运行结果展示

![70307503541](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1703075035410.png)

## 基数排序

### 算法设计

1. 创建一个含有m个队列的队列数组b[]

2. 计算循环次数l

   对于数字的排序，计算循环次数可以用以下的方法：找到待排数据中最大的数据，该数据的位数就是所需的循环次数l。

   对于字符串的排序，由于题目中已经给出字符串的长度相同的条件，所以只需要将这个长度设置为循环次数l。

3. 进入循环`i=1;i<=l;i++`：

4. 扫描数据序列关键码值从右数的第i位，并将其加入到对应的队列中

   对于数字的排序，使用$b[S[k]/10^{i-1}\%10]$ .enqueue(S[k])即可。

   对于字符串的排序，使用`b[S[k].charAt(l-i) - 'a'].enqueue(S[k])`或`b[S[k].charAt(l-i) - 'A'].enqueue(S[k])`即可。

5. 从bucket数组按顺序将数据拷回S中

### 数据设计

由于待排序列的大小未知，所以桶的大小需要灵活变化，因此需要使用链式方式实现的队列LQueue

### 主干代码分析

```java
import java.io.*;

public class RadixSort {
    public static void main(String[] args) throws IOException {
        RadixSort rs = new RadixSort();

        // Construct BufferedReader from FileReader
        BufferedReader br = new BufferedReader(new FileReader("radixSort1.txt"));
        String line = null;

        PrintStream ps = new PrintStream("radixSort1_result.txt");
        //可能会出现异常，直接throws就行了
        System.setOut(ps);
        //把创建的打印输出流赋给系统。即系统下次向 ps输出
        
		//用readLine()方法进行行的读取
        while ((line = br.readLine()) != null) {
            //用split()方法分割字符串
            String[] dataStr = line.split(" ");
            //由于之后都用的是foreach循环，所以要确保数组的大小刚刚合适
            int[] data = new int[dataStr.length];
            //用循环将字符串转化为整型变量
            for(int i = 0; i < dataStr.length; i++){
                data[i] = Integer.parseInt(dataStr[i]);
            }
            //调用排序方法进行排序
            rs.sort_int(data);
            //遍历输出排序结果，将其写入文件中
            for (int element :
                    data) {
                System.out.print(element + " ");
            }
            System.out.println();
        }
        br.close();
    }

    public void sort_int(int[] data){
        LQueue<Integer>[] b = new LQueue[10];
        //创建对象数组后，还需要初始化对象数组才可以使用！
        for(int i = 0; i < 10; i++){
            b[i] = new LQueue<>();
        }

        //find max num
        int max = data[0];
        for (int i:
            data ) {
            if(i>max){
                max = i;
            }
        }
        //get value of l
        int l = 0;
        do{
            l++;
            max = max / 10;
        }while(max!=0);

        //sort
        for(int i = 1; i <= l; i++){
            for (int element :
                    data) {
                b[element / (int) Math.pow(10, i - 1) % 10].enqueue(element);
            }
            //copy back
            //注意每次排完都需要copy back，否则下一次的排序将不能正常进行
            int j = 0;
            for (LQueue<Integer> q :
                    b) {
                while (!q.isEmpty()) {
                    data[j] = q.dequeue().intValue();
                    j++;
                }
            }
        }
    }

    public void sort_string(String[] data){
        LQueue<String>[] b = new LQueue[26];
        for(int i = 0; i < 26; i++){
            b[i] = new LQueue<>();
        }

        //get value of l
        int l = data[0].length();

        //sort
        int index=0;
        char curr;
        for(int i = 1; i <= l; i++){
            for (String element :
                    data) {
                curr = element.charAt(l-i);
                if(curr - 'a' >= 0 && curr - 'z' <= 0){
                    index = curr-'a';
                } else if (curr - 'A' >= 0 && curr - 'Z' <= 0){
                    index = curr-'A';
                } else {
                    System.out.println("invalid char: "+ curr);
                }
                b[index].enqueue(element);
            }
            //copy back
            int j = 0;
            for (LQueue<String> q :
                    b) {
                while (!q.isEmpty()) {
                    data[j] = q.dequeue();
                    j++;
                }
            }
        }
    }
}
```

```java
	/**对于字符串排序的测试代码**/
	public static void main(String[] args) throws IOException {
        RadixSort rs = new RadixSort();

        // Construct BufferedReader from FileReader
        BufferedReader br = new BufferedReader(new FileReader("radixSort2.txt"));
        String line = null;

        PrintStream ps = new PrintStream("radixSort2_result.txt");
        //可能会出现异常，直接throws就行了
        System.setOut(ps);
        //把创建的打印输出流赋给系统。即系统下次向 ps输出

        while ((line = br.readLine()) != null) {
            String[] dataStr = line.split(" ");
            rs.sort_string(dataStr);
            for (String element :
                    dataStr) {
                System.out.print(element + " ");
            }
            System.out.println();
        }
        br.close();

    }
```

### 运行结果展示

因篇幅有限，此处只展示一部分

![70308042010](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1703080420107.png)

![70308050303](F:\1学校课程\3\数据结构\数据结构实验2\数据结构实验2.assets\1703080503033.png)

## 总结与收获

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

基数排序的时间复杂度是$O(k\cdot n)$，其中$n$是排序元素个数，$k$是数字位数。$k$的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；$k$决定了进行多少轮处理，而$n$是每轮处理的操作数目。



# 附录：源代码展示

## 任务一
```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class AList<T> implements List<T>{
    private static final int defaultSize = 512;
    private int msize;
    private int numInList;
    private int curr;
    private T[] listArray;
	//构造函数
    AList(){
        setup(defaultSize);
    }
    //单独的setup函数，方便后面调用
    private void setup(int size){
        msize = size;
        numInList = 0;
        curr = -1;
        listArray = (T[]) new Object[size];
    }
    @Override
    public void insert(T newElement) throws ListException {
        if (isFull()) throw new ListException();
        if(isEmpty()){
            listArray[0] = newElement;
            curr = 0;
        }else {
            for (int i = numInList - 1; i > curr; i--) {
                listArray[i + 1] = listArray[i];
            }
            listArray[curr + 1] = (T) newElement;
            curr++;
        }
        //插入后要将光标右移
        numInList ++;
    }

    @Override
    public void remove() {
        if(isEmpty()) return;
        if(curr==numInList-1){
            curr = 0;
            numInList --;
            return;
        }
        for(int i=curr; i<numInList-1; i++){
            listArray[i] = listArray[i+1];
        }
        numInList--;
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        else if(newElement==null) return;
        else{
            listArray[curr] = newElement;
        }
    }

    @Override
    public void clear() {
        numInList = 0;
        curr = -1;
    }

    @Override
    public boolean isEmpty() {
        return numInList==0;
    }

    @Override
    public boolean isFull() {
        return numInList==msize;
    }

    @Override
    public boolean gotoBeginning() {
        if (!isEmpty()) {
            curr = 0;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoEnd() {
        if(!isEmpty()) {
            curr = numInList - 1;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty() || curr>=numInList - 1) return false;
        curr ++;
        return true;
    }

    @Override
    public boolean gotoPrev() {
        if (!isEmpty() && curr > 0) {
            curr--;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(!isEmpty()) {
            T currElem = (T) listArray[curr];
            return currElem;
        }
        return null;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {capacity = 512, length = "+numInList+", Cursor = " + curr+"}");//要用pw输出，而非System输出
        else{
            for (int i = 0; i < numInList; i++) {
                    pw.print(listArray[i]+" ");
            }
            pw.println("{capacity = " + msize + ", length = " + numInList + ",cursor = " + curr + "}");
        }
    }

    public void showLengthDCapacity(PrintWriter pw) {
        pw.print((double) numInList/msize + ",");
    }

    @Override
    public void moveToNth(int n) {
        if(numInList <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = listArray[curr];
        if(curr <= n){
            for(int i=curr;i < n;i++){
                listArray[i] = listArray[i+1];
            }
        }else {
            for(int i=n;i < curr;i++){
                listArray[i+1] = listArray[i];
            }
        }
        listArray[n] = temp;
        curr = n;
    }

    @Override
    public boolean find(T searchElement) {
        while(true){
            if(listArray[curr].equals(searchElement)){
                return true;
            }
            if(curr==numInList-1){
                return false;
            }
            curr++;
        }
    }
}
```

```java
import java.io.PrintWriter;

public class LListpro<T> implements List<T>{
    private class LinkedNode{
        T element;
        LinkedNode next;
        LinkedNode(T element, LinkedNode next){
            this.element = element;
            this.next = next;
        }
    }

    private LinkedNode dummy;
    private LinkedNode curr;
    private int length;
    LListpro() {
        curr = new LinkedNode(null, new LinkedNode(null, null));
        dummy = curr.next;
        length = 0;
    }


    @Override
    public void insert(T newElement){
        //漏掉了一种可能出现的情况，向空表添加元素，但不是在最初，而是通过若干步删除删成空表
        //此时，表中空无一物，但是curr==dummy而非在最初的"-1位置"
        if(newElement != null){
//            if(curr.next==null){
//                curr.next = new LinkedNode(newElement,null);
//            }
            if(isEmpty()){
                clear();
            }
            LinkedNode temp = curr.next.next;
            curr.next.next = new LinkedNode(newElement,temp);
            length++;
            curr = curr.next;
        }
    }

    @Override
    public void remove() {
        if(!isEmpty() && curr.next!=null){
            curr.next = curr.next.next;
            length--;
        }
        if(curr.next == null){
            curr = dummy;
        }
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        else if (newElement == null) {
            return;
        }else {
            curr.next.element = newElement;
        }
    }

    @Override
    public void clear() {
        curr = new LinkedNode(null, new LinkedNode(null, null));
        dummy = curr.next;
        length = 0;
    }

    @Override
    public boolean isEmpty() {
        return length==0;
    }

    @Override
    public boolean isFull() {
        return false;
    }

    @Override
    public boolean gotoBeginning() {
        if(!isEmpty()){
            curr = dummy;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoEnd() {
        if(!isEmpty()) {
            for (;curr.next!=null && curr.next.next != null; curr = curr.next) ;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty() || curr.next == null || curr.next.next == null) return false;
        curr = curr.next;
        return true;
    }

    @Override
    public boolean gotoPrev() {
        if(!isEmpty()){
            LinkedNode i = dummy;
            for(; i.next!=curr; i = i.next){
                if(i.next==null){
                    return false;
                }
            }
            curr = i;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(!isEmpty()){
            T currElem = curr.next.element;
            return currElem;
        }
        return null;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {length = "+length+", cursor = " + "-1" +"}");
        else {
            LinkedNode temp = dummy.next;
            int cursor = -1;
            for(int i = 0; i < length; i++, temp=temp.next){
                pw.print(temp.element + " ");
                if(curr.next == temp){
                    cursor = i;
                }
            }
            pw.println("{length = " + length + ",cursor = " + cursor + "}");
        }
    }

    @Override
    public void moveToNth(int n) {
        if(length <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = curr.next.element;
        remove();
        curr = dummy;
        for(int i=0; i<n-1; i++){
            curr = curr.next;
        }
        insert(temp);
    }

    @Override
    public boolean find(T searchElement) {
        curr = dummy;
        while(true){
            if(curr.next.element.equals(searchElement)){
                return true;
            }
            if(curr.next.next==null){
                return false;
            }
            curr = curr.next;
        }
    }
}
```

```java
import java.io.PrintWriter;

public class DList<T> implements List<T>{
    private static class DLinkedNode<T>{
        DLinkedNode<T> prev;
        T element;
        DLinkedNode<T> next;
        public DLinkedNode(DLinkedNode<T> prev, T element, DLinkedNode<T> next){
            this.prev = prev;
            this.element = element;
            this.next = next;
        }
    }
    private int length;
    private DLinkedNode<T> head;
    private DLinkedNode<T> curr;
    public DList(){
        setup();
    }
    //独立setup方法
    private void setup(){
        head = new DLinkedNode<>(null,null,null);
        curr = new DLinkedNode<>(null, null, head);
        length = 0;
    }

    //不要只关注任务的完成，每次完成任务后一定要维护好数据间的关系不被破坏！
    //由于没有使用哑结点技术，所以在插入和删除时要分情况讨论。
    @Override
    public void insert(T newElement){
        if(newElement==null) return;
        if(isEmpty()) clear();
        if(isEmpty()){
            head = curr = new DLinkedNode<>(null,newElement,null);
        } else {
            curr.next = new DLinkedNode<>(curr, newElement, curr.next);
            if(curr.next.next!=null) {
                curr.next.next.prev = curr.next;
            }
            curr = curr.next;
        }
        length++;
    }

    //判断条件的书写一定要三思，同时要注意利用逻辑符号的短接性质来避免产生错误。
    @Override
    public void remove() {
        if(isEmpty() || length == 1){
            clear();
            return;
        } else if(curr == head && head.next!=null){
            head = curr = head.next;
            head.prev = null;
        } else if(curr.next == null && curr.prev!=null){
            curr.prev.next = null;
            curr = head;
        }
        else if(curr.next!=null && curr.prev != null){
            DLinkedNode del = curr;
            DLinkedNode delPrev = curr.prev;
            DLinkedNode delNext = curr.next;
            delPrev.next = curr.next;
            delNext.prev = curr.prev;
            curr = delNext;
        }
        length--;
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        if(curr==null) return;
        if(newElement==null) return;
        curr.element = newElement;
    }

    @Override
    public void clear() {
        setup();
    }

    @Override
    public boolean isEmpty() {
        return length==0;
    }

    @Override
    public boolean isFull() {
        return false;
    }

    //移动指针一定要根据接口的要求来移动，并且要注意程序的鲁棒性。
    @Override
    public boolean gotoBeginning() {
        if(!isEmpty()){
           curr = head;
        }
        return true;
    }

    @Override
    public boolean gotoEnd() {
        if(isEmpty()) return false;
        while(curr!=null && curr.next!=null) curr=curr.next;
        return true;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty()) return false;
        if(curr!=null && curr.next!=null){
            curr = curr.next;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoPrev() {
        if(isEmpty()) return false;
        if(curr!= null && curr.prev!=null){
            curr = curr.prev;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(isEmpty()) return null;
        return curr.element;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {length = "+length+", cursor = " + "-1" +"}");
        else {
            int cursor = -2;
            DLinkedNode temp = head;
            if(curr==head){
                cursor = -1;
            }
            int i=-1;
            while(temp!=null){
                i++;
                if(temp==curr){
                    cursor = i;
                }
                pw.print(temp.element + " ");
                temp = temp.next;
            }
            pw.println("{length = " + length + ",cursor = " + cursor + "}");
        }
    }

    @Override
    public void moveToNth(int n) {
        if(length <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = curr.element;
        remove();
        curr = head;
        for(int i=0; i<n-1; i++){
            curr=curr.next;
        }
        insert(temp);
    }

    @Override
    public boolean find(T searchElement) {
        if(isEmpty()) return false;
        curr = head;
        while(true){
            if(curr.element.equals(searchElement)){
                return true;
            }
            if(curr.next==null){
                return false;
            }
            curr = curr.next;
        }
    }
}
```

## 任务二
```java
import java.io.PrintWriter;

public class ResizingAList<T> implements List<T>{
    private int capacity = 1;
    private int length;
    private int curr;
    private T[] listArray;

    ResizingAList(){
        listArray = setup(capacity);
        length = 0;
        curr = -1;
    }
    private T[] setup(int size){
        capacity = size;
        return (T[]) new Object[size];
    }

    private void swell(){
        T[] newArray = setup(2*capacity);
        for(int i=0; i<length; i++){
            newArray[i] = listArray[i];
        }
        listArray = newArray;
    }

    private void shrink(){
        T[] newArray = setup(capacity / 2);
        for(int i = 0; i < length; i ++){
            newArray[i] = listArray[i];
        }
        listArray = newArray;
    }

    @Override
    public void insert(T newElement){
        if (isFull()){
            swell();
        }
        if(isEmpty()){
            listArray[0] = newElement;
            curr = 0;
        }else {
            for (int i = length - 1; i > curr; i--) {
                listArray[i + 1] = listArray[i];
            }
            listArray[curr + 1] = (T) newElement;
            curr++;
        }
        //插入后要将光标右移
        length ++;
    }

    @Override
    public void remove() {
        if(isEmpty()) return;
        if(curr==length-1){
            curr = 0;
            length --;
            return;
        }
        for(int i=curr; i<length-1; i++){
            listArray[i] = listArray[i+1];
        }
        length--;
        if(length <= capacity/4){
            shrink();
        }
    }

    @Override
    public void replace(T newElement) {
        if(isEmpty()) return;
        else if(newElement==null) return;
        else{
            listArray[curr] = newElement;
        }
    }

    @Override
    public void clear() {
        length = 0;
        curr = -1;
    }

    @Override
    public boolean isEmpty() {
        return length==0;
    }

    @Override
    public boolean isFull() {
        return length==capacity;
    }

    @Override
    public boolean gotoBeginning() {
        if (!isEmpty()) {
            curr = 0;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoEnd() {
        if(!isEmpty()) {
            curr = length - 1;
            return true;
        }
        return false;
    }

    @Override
    public boolean gotoNext() {
        if(isEmpty() || curr>=length - 1) return false;
        curr ++;
        return true;
    }

    @Override
    public boolean gotoPrev() {
        if (!isEmpty() && curr > 0) {
            curr--;
            return true;
        }
        return false;
    }

    @Override
    public T getCursor() {
        if(!isEmpty()) {
            T currElem = (T) listArray[curr];
            return currElem;
        }
        return null;
    }

    @Override
    public void showStructure(PrintWriter pw) {
        if(isEmpty()) pw.println("Empty list"+" {capacity = 512, length = "+length+", Cursor = " + curr+"}");//要用pw输出，而非System输出
        else{
            for (int i = 0; i < length; i++) {
                    pw.print(listArray[i]+" ");
            }
            pw.println("{capacity = " + capacity + ", length = " + length + ",cursor = " + curr + "}");
        }
    }

    public void showLengthDCapacity(PrintWriter pw) {
        pw.print((double)length/capacity + ",");
    }

    @Override
    public void moveToNth(int n) {
        if(length <= n){
            System.out.println("moveToNth: List should contain at least n + 1 elements.");
            return;
        }
        T temp = listArray[curr];
        if(curr <= n){
            for(int i=curr;i < n;i++){
                listArray[i] = listArray[i+1];
            }
        }else {
            for(int i=n;i < curr;i++){
                listArray[i+1] = listArray[i];
            }
        }
        listArray[n] = temp;
        curr = n;
    }

    @Override
    public boolean find(T searchElement) {
        while(true){
            if(listArray[curr].equals(searchElement)){
                return true;
            }
            if(curr==length-1){
                return false;
            }
            curr++;
        }
    }
}
```

```java
import java.io.*;

public class ListTest {
    public static void main(String[] args) throws IOException, ListException {
        FileReader fis = new FileReader("list_testcase.txt");
        BufferedReader br = new BufferedReader(fis);
        StreamTokenizer st = new StreamTokenizer(br);
        st.eolIsSignificant(true);
        PrintWriter pw = new PrintWriter("resizingalist_test_result2.txt");
//        List<Character> characterList = new AList<>();
        List<Character> characterList = new ResizingAList<>();
        //List<Character> characterList = new LList<>();
        //List<Character> characterList = new DList<>();
        int token = st.nextToken();
        while (token != StreamTokenizer.TT_EOF){
            char command = (char)st.ttype;
            switch(command){
                case '+' :{
                    st.nextToken();
                    characterList.insert(st.sval.charAt(0));
                    break;
                }
                case '-' :{
                    characterList.remove();
                    break;
                }
                case '=' :{
                    st.nextToken();
                    characterList.replace(st.sval.charAt(0));
                    break;
                }
                case '#' :{
                    characterList.gotoBeginning();
                    break;
                }
                case '*' :{
                    characterList.gotoEnd();
                    break;
                }
                case '>' :{
                    characterList.gotoNext();
                    break;
                }
                case '<' :{
                    characterList.gotoPrev();
                    break;
                }
                case '~' :{
                    characterList.clear();
                    break;
                }
            }
            if(token == StreamTokenizer.TT_EOL || (char) token == '\n'){
                characterList.showLengthDCapacity(pw);
                pw.flush();
//                characterList.clear();
            }
            token = st.nextToken();
        }
//        characterList.showStructure(pw);
        characterList.showLengthDCapacity(pw);
        pw.flush();
        characterList.clear();//需要在文件结束后再做一次输出，因为最后一行的结尾并没有EOL
        pw.close();
        fis.close();
        br.close();
    }
}
```

## 任务三
```java
import 准备工作.LStack;
public class QuickSortStack extends SortAlgorithm{

    //在主函数中写一些用于测试的代码
    public static void main(String[] args){
        int[] testList = {1,2,3,4,5,6,7,7,6,5,4,3,2,1};
        Integer[] test = new Integer[14];
        for (int i = 0; i < 14; i++) {
            test[i] = (Integer) testList[i];
        }
        QuickSortStack qss = new QuickSortStack();
        qss.quick(test, 0, test.length-1);
        for (Integer i :
                test) {
            System.out.print(i + " ");
        }
    }
    //对quick进行的封装，使参数表更简洁
    public void sort(Comparable[] objs) {
        int N = objs.length;
        quick(objs, 0, N - 1);
    }
    //内部类QuickSortOBJ,是一个存储工作块信息的数据类型
    public class QuickSortOBJ {
        private Comparable[] objs;
        private int low;
        private int high;
        private int operationType;
        //构造函数
        public QuickSortOBJ(Comparable[] objs, int low, int high, int operationType){
            this.low = low;
            this.objs = objs;
            this.high = high;
            this.operationType = operationType;
            //0:quicksort
            //1:partition
        }
    }
    //快速排序的主干代码
    public void quick(Comparable[] objs, int low, int high){
        LStack QSLStack = new LStack();
        QuickSortOBJ currTask = new QuickSortOBJ(objs,low,high,0);
        QSLStack.push(currTask);
        //这些之前每轮都要迭代的变量应该放到循环外面进行声明
        int pivotIndex = low;
        while(!QSLStack.isEmpty()){
            currTask = (QuickSortOBJ) QSLStack.pop();
            if (currTask.low >= currTask.high) {
                continue;//这里不应该return，而应该continue!
            }
            if(currTask.operationType == 1){
                pivotIndex = partition(currTask.objs, currTask.low, currTask.high);
            } else {
                QSLStack.push(new QuickSortOBJ(currTask.objs, pivotIndex+1, currTask.high, 0));
                QSLStack.push(new QuickSortOBJ(currTask.objs, currTask.low, pivotIndex-1, 0));
                QSLStack.push(new QuickSortOBJ(currTask.objs, currTask.low, currTask.high, 1));
            }
        }
    }

    //沿用了上一次实验的轴值选择方法：三值选中法
    private Comparable choosePivot(Comparable[] objs, int low, int high){
        int mid = low + (high - low) / 2;
        Comparable pivot = objs[high];
        if (!(less(objs[low], objs[high]) ^ less(objs[mid], objs[low]))) {
            pivot = objs[low];
            exchange(objs, low, high);
        } else if (!(less(objs[mid], objs[low]) ^ less(objs[high], objs[mid]))) {
            pivot = objs[mid];
            exchange(objs, mid, high);
        }
        return pivot;
    }

    //双路划分
    private int partition(Comparable[] objs, int left, int right){
        Comparable pivot = choosePivot(objs,left,right);
        //循环不变量：
        //[left..i) < pivot
        //(j..right-1] > pivot
        int i = left;
        int j = right-1;
        while(i <= j){
            while(i<=j && less(objs[i],pivot)){ // i找大于等于轴值的值，因此在小于轴值时要向右移动
                i++;
            }
            while(i<=j && less(pivot,objs[j])){ // j找小于等于轴值的值，因此在大于轴值时要向左移动
                j--;
            }
            if(i<=j){
                exchange(objs,i,j);
                i++;
                j--;
            }
        }
        exchange(objs,i,right);
        return i;
    }
}
```

```java
import 准备工作.LStack;
import java.util.Scanner;

public class Calculate {
    public static void main(String[] args){
        //提示用户输入
        System.out.println("------------------------------------------------------------------------");
        System.out.println("Please input an arithmetic expression, split every character with space:");

        //读取用户输入
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();

        //进行计算操作
        Calculate cal = new Calculate();
        try {
            System.out.println("= " + cal.calculate(input));
        } catch (InputException e) {
            System.out.println(e.message);
        }
        System.out.println("------------------------------------------------------------------------");
    }

    public double calculate(String input) throws InputException {
        //创建两个栈
        LStack<Operator> opStack = new LStack<>();
        LStack<Double> numStack = new LStack<>();

        //分割字符串
        String[] sList = input.split(" ");

        //创建一些公用的变量
        Operator temp;
        char curr;

        //进行计算操作
        for (String s :
                sList) {
            try {
                numStack.push(Double.parseDouble(s));
            } catch (Exception e){
                if(s.length() == 1 && isValidOperator(s.charAt(0))){
                    curr = s.charAt(0);
                    if(curr == ')'){
                        while((temp = opStack.pop()).operator != '('){
                            operate(temp,numStack);
                            //检查括号不匹配现象
                            if(opStack.isEmpty()){
                                throw new InputException("There is a redundant ')'!");
                            }
                        }
                    } else {
                        //创建一个操作符对象
                        temp = new Operator(curr);
                        if (!opStack.isEmpty() && (temp.precedence <= opStack.topValue().precedence) && ((temp.precedence != opStack.topValue().precedence) || !temp.associativity)) {
                            while (temp.precedence < opStack.topValue().precedence || (temp.precedence == opStack.topValue().precedence && !temp.associativity)) {
                                operate(opStack.pop(), numStack);
                                if (opStack.isEmpty()) break;
                            }
                        }
                        //入栈时调用bracketInStack()方法来修改左括号的优先级
                        temp.bracketInStack();
                        opStack.push(temp);
                    }
                } else {
                    throw new InputException("Input Error!");
                }
            }
        }

        //进行最终的计算操作
        while(!opStack.isEmpty()){
            temp = opStack.pop();
            //判断左括号是否冗余
            if(temp.operator == '('){
                throw new InputException("There is a redundant '('!");
            }
            operate(temp, numStack);
        }

        return numStack.topValue();
    }

    //将具体的计算单独写成一个方法
    private void operate(Operator curr, LStack<Double> numStack){
        double x2 = numStack.pop();
        double x1 = numStack.pop();
        switch (curr.operator) {
            case '+' -> numStack.push(x1 + x2);
            case '-' -> numStack.push(x1 - x2);
            case '*' -> numStack.push(x1 * x2);
            case '/' -> numStack.push(x1 / x2);
            case '^' -> numStack.push(Math.pow(x1, x2));
        }
    }

    //判断是否是有效的操作符
    public boolean isValidOperator(char operator){
        return operator == '+' || operator == '-'
                || operator == '^' || operator == '*'
                || operator == '/' ||operator == '('
                || operator == ')' ;
    }
}
```

```java
public class LeakyStack<T> {
    private static final int DEFAULT_SIZE = 6;
    private int size = 6;
    private int front;
    private int rear;
    private T[] listArray;
	
    //构造方法
    LeakyStack(){
        setup(DEFAULT_SIZE);
    }
    LeakyStack(int capacity){
        setup(capacity+1);
    }
    //独立setup方法
    private void setup(int size){
        this.size = size;
        listArray = (T[]) new Object[size];
        front = 0;
        rear = 0;
    }

    public boolean isFull(){
        if((rear + 1) % size == front){
            return true;
        }
        return false;
    }

    public boolean isEmpty(){
        if(rear == front){
            return true;
        }
        return false;
    }

    /**
     * Push newELement into LeakyStack,
     * and return whether a certain element leaking from the Stack.
     * @param newElement
     * @return "true" if something leaked out
     */
    public boolean push(T newElement){
        boolean flag = false;
        if(isFull()){
            rear = (rear-1+size) % size;
            flag = true;
        }
        //这里先进行Leak和后进行Leak是很有讲究的，
        //如果先push再判断栈满的话，刚刚满的栈就会漏出一个元素，变得不满
        //这样的话push操作后栈永远满不了，而是只能处在“剩一个元素”的状态
        //这样本质上会让栈的容量-1
        listArray[front] = newElement;
        front = (front-1+size) % size;
        return flag;
    }

    /**
     * Pop the element at the top of the stack.
     * @return the popped element
     */
    public T pop(){
        if(!isEmpty()){
            front = (front+1) % size;
            return listArray[front];
        }
        return null;
    }

    /**
     * Get the value of the element at the top of the stack.
     * @return value of that element
     */
    public T topValue(){
        return listArray[(front+1)%size];
    }

    public void clear(){
        setup(size);
    }

    public int length(){
        return (rear - front + size) % size;
    }

    //用StringBuilder来构造输出的字符串
    @Override
    public String toString() {
        if(isEmpty()){
            return "Empty Stack!";
        }
        {
            StringBuilder out = new StringBuilder((length() + 1) * 4);
            out.append("< ");
            for (int i = (front+1)%size; i!=rear; i=(i+1)%size) {
                out.append(listArray[i]);
                out.append(" ");
            }
            out.append(listArray[rear]);
            out.append(" ");
            out.append(">");
            out.append(" {numInStack = ");
            out.append(length());
            out.append("}");
            return out.toString();
        }
    }

    //测试代码
    public static void main(String[] args){
        LeakyStack<Integer> numLS = new LeakyStack<>(6);
        numLS.push(1);
        System.out.println(numLS);
        numLS.push(2);
        System.out.println(numLS);
        numLS.push(3);
        System.out.println(numLS);
        numLS.push(4);
        System.out.println(numLS);
        numLS.push(5);
        System.out.println(numLS);
        numLS.push(6);
        System.out.println(numLS);
        numLS.push(7);
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.clear();
        System.out.println(numLS);
        numLS.pop();
        System.out.println(numLS);
        numLS.push(7);
        System.out.println(numLS);
        numLS.push(8);
        System.out.println(numLS);
        numLS.push(9);
        System.out.println(numLS);
        numLS.push(10);
        System.out.println(numLS);
        numLS.push(11);
        System.out.println(numLS.topValue());
        System.out.println(numLS);
    }
}
```

## 任务四

```java
public interface Queue<T> {
    public void clear();
    public void enqueue(T newElement);
    public T dequeue();
    public T firstValue();
    public boolean isEmpty();
    public int length();
}
```

```java
public class AQueue<T> implements Queue<T> {
    private static final int DEFAULT_SIZE = 6;
    private int size = 6;
    private int front;
    private int rear;
    private T[] listArray;

    //构造函数
    AQueue(){
        setup(DEFAULT_SIZE);
    }
    AQueue(int capacity){
        setup(capacity+1);
    }
    //独立setup方法
    private void setup(int size){
        this.size = size;
        listArray = (T[]) new Object[size];
        front = 0;
        rear = 0;
    }

    public boolean isFull(){
        if((rear + 1) % size == front){
            return true;
        }
        return false;
    }

    public boolean isEmpty(){
        if(rear == front){
            return true;
        }
        return false;
    }

    public void clear(){
        setup(size);
    }

    //入队操作
    @Override
    public void enqueue(T newElement) {
        if(!isFull()) {
            rear = (rear + 1) % size;
            listArray[rear] = newElement;
        }
    }

    //出队操作
    @Override
    public T dequeue() {
        if(!isEmpty()){
            front = (front + 1) % size;
        }
        return null;
    }

    //首元素值的读取
    @Override
    public T firstValue() {
        return listArray[(front+1)%size];
    }

    public int length(){
        return (rear - front + size) % size;
    }

    //使用StringBuider进行字符串构建
    @Override
    public String toString() {
        if(isEmpty()){
            return "Empty Queue!";
        }
        {
            StringBuilder out = new StringBuilder((length() + 1) * 4);
            out.append("< ");
            for (int i = (front+1)%size; i!=rear; i=(i+1)%size) {
                out.append(listArray[i]);
                out.append(" ");
            }
            out.append(listArray[rear]);
            out.append(" ");
            out.append(">");
            out.append(" {numInQueue = ");
            out.append(length());
            out.append("}");
            return out.toString();
        }
    }

    //一些测试代码
    public static void main(String[] args){
        AQueue<Integer> numLS = new AQueue<>(6);
        numLS.enqueue(1);
        System.out.println(numLS);
        numLS.enqueue(2);
        System.out.println(numLS);
        numLS.enqueue(3);
        System.out.println(numLS);
        numLS.enqueue(4);
        System.out.println(numLS);
        numLS.enqueue(5);
        System.out.println(numLS);
        numLS.enqueue(6);
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.clear();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.enqueue(8);
        System.out.println(numLS);
        numLS.enqueue(9);
        System.out.println(numLS);
        numLS.enqueue(10);
        System.out.println(numLS);
        numLS.enqueue(11);
        System.out.println(numLS.firstValue());
        System.out.println(numLS);
    }
}
```

```java
public class LQueue<T> implements Queue<T>{
    //内部类LinkedNode
    private static class LinkedNode<T>{
        T element;
        LinkedNode<T> next;
        public LinkedNode(T element , LinkedNode<T> next){
            this.element = element;
            this.next = next;
        }
    }

    //定义front, rear, length
    private LinkedNode<T> front;
    private LinkedNode<T> rear;
    private int length;

    //constructor
    public LQueue(){
        front = null;
        rear = null;
        length = 0;
    }
    
    //清空队列
    @Override
    public void clear() {
        front = rear = null;
        length = 0;
    }

    //入队操作
    @Override
    public void enqueue (T newElement) {
        if(isEmpty()){
            front = rear = new LinkedNode<T>(newElement,null);
        } else {
            rear.next = new LinkedNode<T>(newElement,null);
            rear = rear.next;
        }
        length++;
    }

    //出队操作
    @Override
    public T dequeue() {
        if(!isEmpty()) {
            LinkedNode<T> temp = front;
            front = front.next;
            length--;
            return temp.element;
        }
        return null;
    }

    //读取首元素
    @Override
    public T firstValue() {
        if(isEmpty()) return null;
        return front.element;
    }

    //判空
    @Override
    public boolean isEmpty() {
        return length==0;
    }

    //判满
    @Override
    public boolean isFull(){
        return false;
    }

    //队长
    @Override
    public int length() {
        return length;
    }

    public String toString()
    {
        if(isEmpty()) return "Empty Queue!";
        StringBuilder out = new StringBuilder((length() + 1) * 4);
        LinkedNode<T> temp = front;
        out.append("< ");
        while(temp != null){
            out.append(temp.element);
            out.append(" ");
            temp = temp.next;
        }
        out.append(">");
        return out.toString();
    }

    //一些测试代码
    public static void main(String[] args){
        LQueue<Integer> numLS = new LQueue<>();
        numLS.enqueue(1);
        System.out.println(numLS);
        numLS.enqueue(2);
        System.out.println(numLS);
        numLS.enqueue(3);
        System.out.println(numLS);
        numLS.enqueue(4);
        System.out.println(numLS);
        numLS.enqueue(5);
        System.out.println(numLS);
        numLS.enqueue(6);
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.clear();
        System.out.println(numLS);
        numLS.dequeue();
        System.out.println(numLS);
        numLS.enqueue(7);
        System.out.println(numLS);
        numLS.enqueue(8);
        System.out.println(numLS);
        numLS.enqueue(9);
        System.out.println(numLS);
        numLS.enqueue(10);
        System.out.println(numLS);
        numLS.enqueue(11);
        System.out.println(numLS.firstValue());
        System.out.println(numLS);
    }
}
```

```java
import java.io.*;

public class RadixSort {
    public static void main(String[] args) throws IOException {
        RadixSort rs = new RadixSort();

        // Construct BufferedReader from FileReader
        BufferedReader br = new BufferedReader(new FileReader("radixSort1.txt"));
        String line = null;

        PrintStream ps = new PrintStream("radixSort1_result.txt");
        //可能会出现异常，直接throws就行了
        System.setOut(ps);
        //把创建的打印输出流赋给系统。即系统下次向 ps输出
        
		//用readLine()方法进行行的读取
        while ((line = br.readLine()) != null) {
            //用split()方法分割字符串
            String[] dataStr = line.split(" ");
            //由于之后都用的是foreach循环，所以要确保数组的大小刚刚合适
            int[] data = new int[dataStr.length];
            //用循环将字符串转化为整型变量
            for(int i = 0; i < dataStr.length; i++){
                data[i] = Integer.parseInt(dataStr[i]);
            }
            //调用排序方法进行排序
            rs.sort_int(data);
            //遍历输出排序结果，将其写入文件中
            for (int element :
                    data) {
                System.out.print(element + " ");
            }
            System.out.println();
        }
        br.close();
    }

    public void sort_int(int[] data){
        LQueue<Integer>[] b = new LQueue[10];
        //创建对象数组后，还需要初始化对象数组才可以使用！
        for(int i = 0; i < 10; i++){
            b[i] = new LQueue<>();
        }

        //find max num
        int max = data[0];
        for (int i:
            data ) {
            if(i>max){
                max = i;
            }
        }
        //get value of l
        int l = 0;
        do{
            l++;
            max = max / 10;
        }while(max!=0);

        //sort
        for(int i = 1; i <= l; i++){
            for (int element :
                    data) {
                b[element / (int) Math.pow(10, i - 1) % 10].enqueue(element);
            }
            //copy back
            //注意每次排完都需要copy back，否则下一次的排序将不能正常进行
            int j = 0;
            for (LQueue<Integer> q :
                    b) {
                while (!q.isEmpty()) {
                    data[j] = q.dequeue().intValue();
                    j++;
                }
            }
        }
    }

    public void sort_string(String[] data){
        LQueue<String>[] b = new LQueue[26];
        for(int i = 0; i < 26; i++){
            b[i] = new LQueue<>();
        }

        //get value of l
        int l = data[0].length();

        //sort
        int index=0;
        char curr;
        for(int i = 1; i <= l; i++){
            for (String element :
                    data) {
                curr = element.charAt(l-i);
                if(curr - 'a' >= 0 && curr - 'z' <= 0){
                    index = curr-'a';
                } else if (curr - 'A' >= 0 && curr - 'Z' <= 0){
                    index = curr-'A';
                } else {
                    System.out.println("invalid char: "+ curr);
                }
                b[index].enqueue(element);
            }
            //copy back
            int j = 0;
            for (LQueue<String> q :
                    b) {
                while (!q.isEmpty()) {
                    data[j] = q.dequeue();
                    j++;
                }
            }
        }
    }
}
```

